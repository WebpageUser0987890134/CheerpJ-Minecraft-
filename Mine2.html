<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sandbox with Controlled Movement & Precise Cursor</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    user-select: none;
  }
  pre {
    font-size: 18px;
    line-height: 1.1;
    letter-spacing: 0.1em;
  }
  #mode, #sizeSelectContainer {
    margin-top: 10px;
  }
  button {
    margin-right: 8px;
    font-size: 16px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="sizeSelectContainer">
  Choose world size: 
  <button id="sizeSmall">Small (20x15)</button>
  <button id="sizeMedium">Medium (40x15)</button>
  <button id="sizeLarge">Large (80x15)</button>
</div>

<pre id="screen" style="display:none;"></pre>
<div id="mode" style="display:none;"></div>

<script>
(() => {
  const VIEW_WIDTH = 20;
  const VIEW_HEIGHT = 15;

  const WORLD_SIZES = {
    small: 20,
    medium: 40,
    large: 80
  };

  const TILE_AIR = '\u2800';    // Invisible braille blank for air
  const TILE_BLOCK = '⊞';       // Solid block
  const TILE_SPECIAL = '⛝';     // Special block
  const TILE_WATER = '≈';       // Water block

  let worldWidth = 0;
  const worldHeight = VIEW_HEIGHT;

  let grid = [];
  let player = {x: 0, y: 0, vy: 0, onGround: false};
  let cursor = {x: 0, y: 0};
  let cursorMode = false;
  let viewportX = 0;

  const sizeSelectContainer = document.getElementById('sizeSelectContainer');
  const screen = document.getElementById('screen');
  const modeDisplay = document.getElementById('mode');

  function initGrid(width) {
    grid = [];
    for(let y=0; y<worldHeight; y++) {
      grid[y] = [];
      for(let x=0; x<width; x++) {
        grid[y][x] = TILE_AIR;
      }
    }
  }

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  // Generate smooth terrain heights
  function generateHeights(width) {
    let heights = [];
    let baseHeight = worldHeight - 4;
    let variation = 3;
    let currentHeight = baseHeight;

    for(let x=0; x<width; x++) {
      let change = Math.floor(Math.random() * 3) - 1;
      currentHeight += change;
      currentHeight = clamp(currentHeight, baseHeight - variation, baseHeight + variation);
      heights[x] = currentHeight;
    }
    return heights;
  }

  // Cellular automata cave carving underground
  function generateCaves(heights) {
    // Fill underground solid
    for(let y=0; y<worldHeight; y++) {
      for(let x=0; x<worldWidth; x++) {
        if(y >= heights[x]) {
          grid[y][x] = TILE_BLOCK;
        } else {
          grid[y][x] = TILE_AIR;
        }
      }
    }

    // Initial random fill of caves underground (below surface - 2)
    for(let y=0; y<worldHeight; y++) {
      for(let x=0; x<worldWidth; x++) {
        if(y >= heights[x] + 2) {
          grid[y][x] = Math.random() < 0.45 ? TILE_AIR : TILE_BLOCK;
        }
      }
    }

    // Cellular automata iterations
    let iterations = 4;
    for(let i=0; i<iterations; i++) {
      let newGrid = [];
      for(let y=0; y<worldHeight; y++) {
        newGrid[y] = [];
        for(let x=0; x<worldWidth; x++) {
          let neighbors = 0;
          for(let dy=-1; dy<=1; dy++) {
            for(let dx=-1; dx<=1; dx++) {
              if(dx === 0 && dy === 0) continue;
              let nx = x+dx;
              let ny = y+dy;
              if(nx < 0 || ny < 0 || nx >= worldWidth || ny >= worldHeight) {
                neighbors++;
              } else if(grid[ny][nx] === TILE_BLOCK) {
                neighbors++;
              }
            }
          }
          if(grid[y][x] === TILE_BLOCK) {
            newGrid[y][x] = (neighbors >= 4) ? TILE_BLOCK : TILE_AIR;
          } else {
            newGrid[y][x] = (neighbors >= 5) ? TILE_BLOCK : TILE_AIR;
          }
        }
      }
      grid = newGrid;
    }
  }

  // Generate water in low cave spots
  function generateWater(heights) {
    for(let x=2; x<worldWidth-2; x++) {
      for(let y=heights[x] + 2; y<worldHeight-1; y++) {
        // Put water if tile is air but block below is solid
        if(grid[y][x] === TILE_AIR && grid[y+1][x] === TILE_BLOCK) {
          if(Math.random() < 0.1) {
            grid[y][x] = TILE_WATER;
          }
        }
      }
    }
  }

  // Place special blocks floating above ground
  function placeSpecialBlocks(heights) {
    let count = Math.floor(worldWidth / 10);
    for(let i=0; i<count; i++) {
      let sx = Math.floor(Math.random() * worldWidth);
      let sy = Math.floor(Math.random() * (heights[sx] - 2));
      if(sy >= 0 && grid[sy][sx] === TILE_AIR) {
        grid[sy][sx] = TILE_SPECIAL;
      }
    }
  }

  function generateWorld(width) {
    worldWidth = width;
    initGrid(worldWidth);
    let heights = generateHeights(worldWidth);

    generateCaves(heights);
    generateWater(heights);
    placeSpecialBlocks(heights);

    // Start player above ground roughly middle of viewport
    player.x = Math.floor(worldWidth / 2);
    player.y = heights[player.x] - 1;
    player.vy = 0;
    player.onGround = false;

    cursor.x = player.x;
    cursor.y = player.y;
    viewportX = clamp(player.x - Math.floor(VIEW_WIDTH / 2), 0, worldWidth - VIEW_WIDTH);
  }

  const TILE_TYPES = [TILE_AIR, TILE_BLOCK, TILE_SPECIAL, TILE_WATER];

  function isBlocked(x, y) {
    if(y < 0 || y >= worldHeight || x < 0 || x >= worldWidth) return true;
    const tile = grid[Math.floor(y)][x];
    return tile === TILE_BLOCK || tile === TILE_SPECIAL;
  }

  function isWater(x, y) {
    if(y < 0 || y >= worldHeight || x < 0 || x >= worldWidth) return false;
    return grid[Math.floor(y)][x] === TILE_WATER;
  }

  let keysDown = new Set();
  let placeCooldown = 0;
  let jumpPressed = false;

  // Movement timing variables
  let moveDelay = 15; // frames delay before repeat starts (~250ms)
  let moveRepeatRate = 4; // frames between repeated moves (~66ms)
  let moveCounter = 0;
  let lastMoveDir = 0; // -1 left, 1 right, 0 no move

  // Track Ctrl key for cycling tiles
  let ctrlDown = false;

  // For one-step cursor movement:
  let prevKeysDown = new Set();

  window.addEventListener('keydown', e => {
    keysDown.add(e.key);
    if(e.key === 'Control') ctrlDown = true;
    e.preventDefault();

    if(e.key === 'z' || e.key === 'Z') {
      cursorMode = true;
      draw();
    }
  });

  window.addEventListener('keyup', e => {
    keysDown.delete(e.key);
    if(e.key === 'Control') ctrlDown = false;
    e.preventDefault();

    if(e.key === 'z' || e.key === 'Z') {
      cursorMode = false;
      draw();
    }
  });

  function updatePhysics() {
    if (isWater(player.x, Math.floor(player.y) + 1)) {
      if (!player.onGround) {
        player.vy += 0.05;  
        if (player.vy > 0.5) player.vy = 0.5;
      }
    } else {
      if (!player.onGround) {
        player.vy += 0.1;  // gravity in air
        if (player.vy > 1) player.vy = 1;  // max fall speed
      }
    }

    let newY = player.y + player.vy;

    if (player.vy > 0) {
      for (let yCheck = Math.floor(player.y) + 1; yCheck <= Math.floor(newY); yCheck++) {
        if (isBlocked(player.x, yCheck)) {
          player.y = yCheck - 1;
          player.vy = 0;
          player.onGround = true;
          return;
        }
        if (isWater(player.x, yCheck)) {
          player.vy = 0;
          player.onGround = true;
          return;
        }
      }
      player.y = newY;
      player.onGround = false;
    } else if (player.vy < 0) {
      for (let yCheck = Math.floor(player.y) - 1; yCheck >= Math.floor(newY); yCheck--) {
        if (isBlocked(player.x, yCheck) || isWater(player.x, yCheck)) {
          player.vy = 0;
          return;
        }
      }
      player.y = newY;
      player.onGround = false;
    } else {
      player.onGround = isBlocked(player.x, Math.floor(player.y) + 1) || isWater(player.x, Math.floor(player.y) + 1);
    }

    player.y = clamp(player.y, 0, worldHeight - 1);
  }

  function draw() {
    let output = '';
    for(let y=0; y<VIEW_HEIGHT; y++) {
      for(let x=0; x<VIEW_WIDTH; x++) {
        let worldX = x + viewportX;
        if(cursorMode && worldX === cursor.x && y === cursor.y) {
          output += '⮽ ';
        } else if(!cursorMode && worldX === player.x && y === Math.floor(player.y)) {
          output += '⯀ ';
        } else if(worldX >= 0 && worldX < worldWidth) {
          output += grid[y][worldX] + ' ';
        } else {
          output += TILE_AIR + ' ';
        }
      }
      output += '\n';
    }
    screen.textContent = output;
    modeDisplay.textContent = 'Mode: ' + (cursorMode ? 'Move Cursor (Z held)' : 'Move Player') + (ctrlDown ? ' + Ctrl (cycle block)' : '');
  }

  function movePlayer(dx) {
    let targetX = player.x + dx;
    if(targetX < 0 || targetX >= worldWidth) return;

    if(!isBlocked(targetX, Math.floor(player.y))) {
      player.x = targetX;

      if(player.x - viewportX < 5 && viewportX > 0) {
        viewportX = clamp(viewportX - 1, 0, worldWidth - VIEW_WIDTH);
      } else if(player.x - viewportX > VIEW_WIDTH - 6 && viewportX < worldWidth - VIEW_WIDTH) {
        viewportX = clamp(viewportX + 1, 0, worldWidth - VIEW_WIDTH);
      }
    }
  }

  // Cycle tile types at position
  function cycleTile(x, y) {
    let current = grid[y][x];
    let idx = TILE_TYPES.indexOf(current);
    idx = (idx + 1) % TILE_TYPES.length;
    grid[y][x] = TILE_TYPES[idx];
  }

  function handleInput() {
    if (cursorMode) {
      // Move cursor only on fresh key press (key just pressed down)
      ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].forEach(key => {
        if (keysDown.has(key) && !prevKeysDown.has(key)) {
          if (key === 'ArrowUp') cursor.y = clamp(cursor.y - 1, 0, worldHeight - 1);
          else if (key === 'ArrowDown') cursor.y = clamp(cursor.y + 1, 0, worldHeight - 1);
          else if (key === 'ArrowLeft') cursor.x = clamp(cursor.x - 1, 0, worldWidth - 1);
          else if (key === 'ArrowRight') cursor.x = clamp(cursor.x + 1, 0, worldWidth - 1);
        }
      });

      prevKeysDown = new Set(keysDown); // update last keys

      // Ctrl cycles tile under cursor
      if (ctrlDown) {
        cycleTile(cursor.x, cursor.y);
      }

      // Continuous block placing if holding Z + X
      if (keysDown.has('z') && keysDown.has('x')) {
        if (placeCooldown <= 0) {
          cycleTile(cursor.x, cursor.y);
          placeCooldown = 10;
        }
      } else {
        placeCooldown = 0;
      }
    } else {
      // Movement with repeat delay
      let dir = 0;
      if (keysDown.has('ArrowLeft')) dir = -1;
      else if (keysDown.has('ArrowRight')) dir = 1;

      if (dir !== 0) {
        if (dir !== lastMoveDir) {
          moveCounter = moveDelay;
          movePlayer(dir);
        } else {
          if (moveCounter <= 0) {
            movePlayer(dir);
            moveCounter = moveRepeatRate;
          } else {
            moveCounter--;
          }
        }
      } else {
        moveCounter = 0;
      }
      lastMoveDir = dir;

      // Jump on key down, no continuous jump while holding
      if (keysDown.has('ArrowUp') && player.onGround && !jumpPressed) {
        player.vy = -0.9;
        player.onGround = false;
        jumpPressed = true;
      }
      if (!keysDown.has('ArrowUp')) {
        jumpPressed = false;
      }

      // Ctrl cycles tile under player
      if (ctrlDown) {
        cycleTile(player.x, Math.floor(player.y));
      }
    }
  }

  function gameLoop() {
    handleInput();
    updatePhysics();
    draw();
    if (placeCooldown > 0) placeCooldown--;
    requestAnimationFrame(gameLoop);
  }

  document.getElementById('sizeSmall').onclick = () => {
    generateWorld(WORLD_SIZES.small);
    sizeSelectContainer.style.display = 'none';
    screen.style.display = 'block';
    modeDisplay.style.display = 'block';
    draw();
    requestAnimationFrame(gameLoop);
  };
  document.getElementById('sizeMedium').onclick = () => {
    generateWorld(WORLD_SIZES.medium);
    sizeSelectContainer.style.display = 'none';
    screen.style.display = 'block';
    modeDisplay.style.display = 'block';
    draw();
    requestAnimationFrame(gameLoop);
  };
  document.getElementById('sizeLarge').onclick = () => {
    generateWorld(WORLD_SIZES.large);
    sizeSelectContainer.style.display = 'none';
    screen.style.display = 'block';
    modeDisplay.style.display = 'block';
    draw();
    requestAnimationFrame(gameLoop);
  };
})();
</script>

</body>
</html>
